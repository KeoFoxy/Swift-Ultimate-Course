<img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/swift/swift-original.svg" height='120' align="right"/>

# Swift-Ultimate-Course  


### SOLID

**SOLID** - это акроним, который описывает пять основных принципов объектно-ориентированного программирования и проектирования:

S - Принцип единственной ответственности (Single Responsibility Principle)
O - Принцип открытости/закрытости (Open Closed Principle)
L - Принцип подстановки Барбары Лисков (Liskov Substitution Principle)
I - Принцип разделения интерфейса (Interface Segregation Principle)
D - Принцип инверсии зависимостей (Dependency Inversion Principle)


#### Single Responsibility Principle

Каждый класс должен отвечать только за одну операцию.

Если класс отвечает за несколько операций сразу, вероятность возникновения багов возрастает – внося изменения, касающиеся одной из операций вы, сами того не подозревая, можете затронуть и другие.

Принцип служит для разделения типов поведения, благодаря которому ошибки, вызванные модификациями в одном поведении, не распространялись на прочие, не связанные с ним типы.

```swift
// Неправильно
class UserSettings {
    let user: User

    init(user: User) {
        self.user = user
    }

    func changeSettings() {
        // Изменение настроек
    }

    func save() {
        // Сохранение настроек
    }
}

// Правильно
class UserSettings {
    let user: User

    init(user: User) {
        self.user = user
    }

    func changeSettings() {
        // Изменение настроек
    }
}

class UserSettingsStorage {
    let settings: UserSettings

    init(settings: UserSettings) {
        self.settings = settings
    }

    func save() {
        // Сохранение настроек
    }
}

```

#### Open Closed Principle

Классы должны  быть  открыты для расширения, но закрыты для модификации.

Когда вы меняете текущее поведение класса, эти изменения сказываются на всех системах, работающих с данным классом. Если хотите, чтобы класс выполнял больше операций, то идеальный вариант – не заменять старые на новые, а добавлять новые к уже существующим.

Принцип служит для того, чтобы делать поведение класса более разнообразным, не вмешиваясь в текущие операции, которые он выполняет. Благодаря этому вы избегаете ошибок в тех фрагментах кода, где задействован этот класс.

```swift
// Неправильно
class Discount {
    let user: User

    init(user: User) {
        self.user = user
    }

    func giveDiscount() -> Double {
        if user.type == .vip {
            return 0.2
        } else {
            return 0.1
        }
    }
}

// Правильно
protocol DiscountStrategy {
    func calculate() -> Double
}

class VipDiscount: DiscountStrategy {
    func calculate() -> Double {
        return 0.2
    }
}

class RegularDiscount: DiscountStrategy {
    func calculate() -> Double {
        return 0.1
    }
}

class Discount {
    let strategy: DiscountStrategy

    init(strategy: DiscountStrategy) {
        self.strategy = strategy
    }

    func giveDiscount() -> Double {
        return strategy.calculate()
    }
}

```

#### Liskov Substitution Principle

Если П является подтипом Т, то любые объекты типа Т, присутствующие в программе, могут заменяться объектами типа П без негативных последствий для функциональности программы

В случаях, когда класс-потомок не способен выполнять те же действия, что и класс-родитель, возникает риск появления ошибок.

Если у вас имеется класс и вы создаете на его базе другой класс, исходный класс становится родителем, а новый – его потомком. Класс-потомок должен производить такие же операции, как и класс-родитель. Это называется наследственностью.

Необходимо, чтобы класс-потомок был способен обрабатывать те же запросы, что и родитель, и выдавать тот же результат. Или же результат может отличаться, но при этом относиться к тому же типу. На картинке это показано так: класс-родитель подаёт кофе (в любых видах), значит, для класса-потомка приемлемо подавать капучино (разновидность кофе), но неприемлемо подавать воду.

Если класс-потомок не удовлетворяет этим требованиям, значит, он слишком сильно отличается от родителя и нарушает принцип.

Принцип служит для того, чтобы обеспечить постоянство: класс-родитель и класс-потомок могут использоваться одинаковым образом без нарушения работы программы.

```swift
// Правильно
class Bird {
    func fly() {
        // Реализация полета
    }
}

class Duck: Bird {
    override func fly() {
        // Реализация полета для утки
    }
}

class Ostrich: Bird {
    override func fly() {
        // Ошибка! Страусы не летают
    }
}
```

#### Interface Segregation Principle

Не следует ставить клиент в зависимость от методов, которые он не использует.

Когда классу приходится производить действия, не несущие никакой реальной пользы, это выливается в пустую трату ресурса, а в случае, если класс выполнять эти действия не способен, ведёт к возникновению багов.

Класс должен производить только те операции, которые необходимы для осуществления его функций. Все другие действия следует либо удалить совсем, либо переместить, если есть вероятность, что они понадобятся другому классу в будущем.

Принцип служит для того, чтобы раздробить единый набор действий на ряд наборов поменьше – таким образом, каждый класс делает то, что от него действительно требуется, и ничего больше.

```swift
// Неправильно
protocol Worker {
    func work()
    func eat()
}

class Human: Worker {
    func work() {
        // Работа
    }

    func eat() {
        // Еда
    }
}

class Robot: Worker {
    func work() {
        // Работа
    }

    func eat() {
        // Ошибка! Роботы не едят
    }
}

// Правильно
protocol Workable {
    func work()
}

protocol Eatable {
    func eat()
}

class Human: Workable, Eatable {
    func work() {
        // Работа
    }

    func eat() {
        // Еда
    }
}

class Robot: Workable {
    func work() {
        // Работа
    }
}
```

#### Dependency Inversion

Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те, и другие должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

Для начала объясню термины, которые здесь применяются, простыми словами.

Модули (или классы) верхнего уровня = классы, которые выполняют операцию при помощи инструмента
Модули (или классы) нижнего уровня = инструменты, которые нужны для выполнения операций
Абстракции – представляют интерфейс, соединяющий два класса
Детали = специфические характеристики работы инструмента

Согласно данному принципу, класс не должен соединяться с инструментом, который применяет для выполнения операции. Вместо этого он должен быть соединён с интерфейсом, который поможет установить связь между инструментом и классом.

Кроме того, принцип гласит, что ни интерфейс, ни класс, не обязаны вникать в специфику работы инструмента. Напротив, это инструмент должен подходить под требования интерфейса.

Этот принцип служит для того, чтобы устранить зависимость классов верхнего уровня от классов нижнего уровня за счёт введения интерфейсов.

```swift
// Неправильно
class LightBulb {
    func turnOn() {
        // Включить лампочку
    }

    func turnOff() {
        // Выключить лампочку
    }
}

class ElectricPowerSwitch {
    let lightBulb: LightBulb

    init(lightBulb: LightBulb) {
        self.lightBulb = lightBulb
    }

    func press() {
        lightBulb.turnOn()
        lightBulb.turnOff()
    }
}

// Правильно
protocol Switchable {
    func turnOn()
    func turnOff()
}

class LightBulb: Switchable {
    func turnOn() {
        // Включить лампочку
    }

    func turnOff() {
        // Выключить лампочку
    }
}

class ElectricPowerSwitch {
    let device: Switchable

    init(device: Switchable) {
        self.device = device
    }

    func press() {
        device.turnOn()
        device.turnOff()
    }
}
```

### Unit test

Принцип **FIRST** - это набор рекомендаций, которые помогают написать хорошие и эффективные тесты. Этот акроним означает:

F - Fast (Быстрый)
I - Independent/Isolated (Независимый)
R - Repeatable (Повторяемый)
S - Self-Validating (Самопроверяемый)
T - Timely/Thorough (Своевременный/Тщательный)

#### Fast
Тесты должны быть быстрыми, чтобы их можно было запускать часто без значительных затрат времени. Это позволяет быстро получать обратную связь о том, работает ли код так, как ожидается.

####  Independent/Isolated

Каждый тест должен быть независимым от других тестов. Это означает, что тесты не должны зависеть друг от друга и должны быть способными работать в любом порядке.

```swift
import XCTest
@testable import YourApp

class IndependentTest: XCTestCase {
    func testAddition() {
        let result = 2 + 2
        XCTAssertEqual(result, 4)
    }

    func testSubtraction() {
        let result = 2 - 2
        XCTAssertEqual(result, 0)
    }
}
```

#### Repeatable 
Тест должен давать одинаковые результаты, независимо от того, сколько раз он был запущен, при условии, что код не менялся.

#### Self-Validating (Самопроверяемый)
Тест должен автоматически проверять свои результаты и не требовать ручной проверки.

####  Timely/Thorough (Своевременный/Тщательный)
Тесты должны быть написаны своевременно, то есть до написания самого кода (подход TDD - Test-Driven Development). Они также должны быть тщательными и проверять все возможные сценарии.


### User Defaults

UserDefaults - это интерфейс, который позволяет приложению взаимодействовать с базой данных пользовательских настроек на уровне операционной системы. Это удобный способ хранить небольшие объемы данных между сеансами работы приложения, такие как настройки пользователя или состояние приложения.

#### Сохранение данных

Вы можете сохранить данные, используя метод set и ключ, который вы выберете. 

```swift
let defaults = UserDefaults.standard
defaults.set("Hello, World!", forKey: "Greeting")
```
#### Чтение данных

Вы можете получить данные, используя метод `object` или специальные методы, такие как `string`, `array`, `dictionary`, `data`, `URL`, `bool`, `integer`, `float` и `double`. Здесь мы получаем строку:

```swift
let defaults = UserDefaults.standard
let greeting = defaults.string(forKey: "Greeting")
print(greeting) // Выводит: Optional("Hello, World!")
```

#### Удаление данных

Вы можете удалить данные, используя метод `removeObject`:

```swift
let defaults = UserDefaults.standard
defaults.removeObject(forKey: "Greeting")
```

#### Проверка на наличие данных

Вы можете проверить, есть ли данные для определенного ключа, используя метод `object`:

```swift
let defaults = UserDefaults.standard
if defaults.object(forKey: "Greeting") != nil {
    print("Greeting exists")
} else {
    print("Greeting does not exist")
}
```

#### Сохранение пользовательских объектов

UserDefaults может хранить любые объекты, которые поддерживают протокол `NSCoding`. Это включает в себя большинство основных типов данных Swift и некоторые другие типы, такие как `UIColor` и `UIImage`. Если вы хотите сохранить свой собственный пользовательский объект, вы должны сделать его совместимым с `NSCoding`.

```swift
class MyObject: NSObject, NSCoding {
    var name: String

    init(name: String) {
        self.name = name
    }

    required init?(coder aDecoder: NSCoder) {
        name = aDecoder.decodeObject(forKey: "name") as? String ?? ""
    }

    func encode(with aCoder: NSCoder) {
        aCoder.encode(name, forKey: "name")
    }
}

let myObject = MyObject(name: "My Object")
let defaults = UserDefaults.standard
let encodedData: Data = NSKeyedArchiver.archivedData(withRootObject: myObject)
defaults.set(encodedData, forKey: "myObject")

if let data = defaults.data(forKey: "myObject"),
   let myObject = NSKeyedUnarchiver.unarchiveObject(with: data) as? MyObject {
    print(myObject.name) // Выводит: "My Object"
}
```

### Weak

Weak в Swift используется для предотвращения утечек памяти в вашем приложении. Когда два экземпляра класса имеют сильные ссылки друг на друга, создается цикл сильных ссылок(Retain Cycle), и это может привести к утечкам памяти. Использование`weak` позволяет вам разорвать этот цикл.

```swift
class Person {
    let name: String
    init(name: String) { self.name = name }
    var apartment: Apartment?
    deinit { print("\(name) is being deinitialized") }
}

class Apartment {
    let unit: String
    init(unit: String) { self.unit = unit }
    weak var tenant: Person?
    deinit { print("Apartment \(unit) is being deinitialized") }
}

var john: Person? = Person(name: "John Appleseed")
var unit4A: Apartment? = Apartment(unit: "4A")

john!.apartment = unit4A
unit4A!.tenant = john

john = nil
unit4A = nil
```

### Automatic Reference Counting

ARC или Automatic Reference Counting - это система управления памятью, используемая Swift для отслеживания и управления памятью вашего приложения. Каждый раз, когда вы создаете экземпляр класса, ARC резервирует блок памяти для хранения информации об этом экземпляре. Эта память освобождается, когда экземпляр больше не нужен.

ARC отслеживает количество активных ссылок на каждый экземпляр (счетчик ссылок). Когда вы присваиваете экземпляр переменной или константе, ARC увеличивает счетчик ссылок. Когда ссылка на экземпляр удаляется, ARC уменьшает счетчик ссылок. Когда счетчик ссылок достигает нуля, ARC освобождает память, занятую экземпляром.

MRC — Manual Reference Counter (ручное управление счетчиком ссылок). Значит нужно самостоятельно добавлять в код вызов функций alloc, retain, release, dealloc для управления счетчика.


### Жизненный цикл ViewController'a

**ViewDidLoad** — метод вызывается, когда view уже создано. Метод вызывается только один раз за время существования ViewController.

**ViewWillAppear** — метод вызывается каждый раз перед тем, как появится ViewController. Этот метод может быть вызван несколько раз для одного экземпляра ViewController. 

**ViewDidAppear** — метод вызывается каждый раз после появления ViewController. 

**ViewWillDisappear** — метод вызывается перед удалением ViewController из иерархии представлений. 

**ViewDidDisappear** — метод вызывается после удаления ViewController из иерархии представлений.


### В чем разница sync и async? 

**sync** — возвращает управление на текущую очередь только после завершения задания, **async** — возвращает управление на текущую очередь немедленно после запуска задания, не ожидая завершения.


### Состояния приложения

**Non-running** — приложение не запущено. 

**Inactive** — приложение работает в Foreground, но не получает события. iOS приложение переходит в состояние Inactive когда поступает событие звонка или SMS-сообщения. 

**Active** — приложение работает в Foreground (на переднем плане) и получает события.

**Background** — приложение работает в Background (в фоновом режиме) и выполняет код.

**Suspended** — приложение находится в Background, но код уже не выполняется. Система может завершить ваше приложение для оптимизации памяти.


### В чем разница между frame и bounds?

`frame` определяет прямоугольник в системе координат родительского представления, в котором размещается представление. `bounds` определяет прямоугольник в собственной системе координат представления.

### Что такое delegate и как это работает?

`delegate` — это паттерн проектирования, который позволяет одному объекту делегировать выполнение методов другому объекту. Это часто используется в iOS для обратного вызова, например, когда `UITableView` требует у своего делегата информацию о том, сколько строк ему отображать.

### Как вы бы сохраняли данные пользователя?
Для легковесных данных, таких как настройки, можно использовать **UserDefaults**. Для более сложных структур данных или больших объемов данных можно использовать **CoreData** или сторонние решения, такие как **Realm**. Для конфиденциальных данных, таких как пароли или ключи, следует использовать **Keychain**.

### Что такое REST API? Какие основные HTTP методы вы знаете?
REST (Representational State Transfer) — это архитектурный стиль, который определяет набор ограничений для создания веб-сервисов. Основные HTTP методы в REST включают **GET** (получение данных), **POST** (создание данных), **PUT** (обновление данных), **DELETE** (удаление данных) и **PATCH** (частичное обновление данных).

Ошибки:

4xx: Ошибки клиента. Например, 404 означает "Не найдено", а 403 - "Запрещено".
5xx: Ошибки сервера. Например, 500 означает "Внутренняя ошибка сервера".

### Протоколы

Протоколы в Swift играют важную роль и представляют собой мощный инструмент для создания гибких и расширяемых систем. Протокол определяет "контракт" или набор методов и свойств, которые должен реализовать класс, структура или перечисление.

Зачем они нужны:

* Абстракция: Протоколы позволяют определить интерфейс, который должен быть реализован, не привязываясь к конкретной реализации. Это позволяет разрабатывать более модульные и гибкие системы.

* Множественное наследование: В отличие от многих других языков программирования, Swift не поддерживает множественное наследование для классов. Однако с помощью протоколов вы можете создать что-то подобное множественному наследованию, позволяя одному типу реализовывать множество протоколов.

* Расширяемость: С помощью расширений (extensions) вы можете добавлять новые методы или свойства к существующим типам, которые соответствуют определенному протоколу.

* Типовая безопасность: Протоколы позволяют определить ожидаемые типы данных, что делает код более безопасным и предсказуемым.

Примеры использования:

* Делегирование: Это распространенный паттерн в iOS, где один объект делегирует выполнение некоторых функций другому объекту. Например, UITableView делегирует решение о том, сколько строк отображать и какой контент показывать, своему делегату, который соответствует протоколу UITableViewDelegate.

* Определение интерфейсов: Если вы создаете библиотеку или фреймворк, вы можете использовать протоколы для определения того, как другие разработчики должны взаимодействовать с вашим кодом.

* Расширение типов: Вы можете использовать протоколы в сочетании с расширениями, чтобы добавить новую функциональность к существующим типам. Например, вы можете создать протокол Printable и затем реализовать его для стандартного типа Int, добавив метод для печати.

```swift
protocol Drivable {
    var speed: Int { get set }
    func drive()
}

class Car: Drivable {
    var speed = 0

    func drive() {
        print("Driving at \(speed) mph")
    }
}
```

### Generics

Генерики (или параметрический полиморфизм) — это одна из наиболее мощных особенностей Swift, позволяющая создавать гибкий и многоразовый код.

Что такое генерики?

Генерики позволяют создавать определения функций, методов, классов, структур и перечислений, которые работают с типами, определенными позже. Это позволяет избежать дублирования кода и создает более абстрактные, гибкие и многоразовые решения.

Пример без генериков:

Допустим, вы хотите создать функцию, которая меняет местами значения двух переменных. Без генериков вам пришлось бы создавать отдельную функцию для каждого типа:

```swift
func swapTwoInts(_ a: inout Int, _ b: inout Int) {
    let temporaryA = a
    a = b
    b = temporaryA
}

func swapTwoStrings(_ a: inout String, _ b: inout String) {
    let temporaryA = a
    a = b
    b = temporaryA
}
```

Пример с генериками:

С помощью генериков вы можете создать одну функцию, которая работает с любым типом:

```swift
func swapTwoValues<T>(_ a: inout T, _ b: inout T) {
    let temporaryA = a
    a = b
    b = temporaryA
}
```

Зачем использовать генерики?

* Многоразовость: Один код может работать с различными типами данных.
* Типовая безопасность: Генерики позволяют писать код, который не теряет информацию о типе.
* Большая производительность: Во многих случаях генерики позволяют избежать динамической диспетчеризации, что делает код быстрее.

### Многопоточность

Многопоточность — это ключевой аспект в разработке современных приложений, позволяющий выполнять несколько задач одновременно. В Swift и iOS для работы с многопоточностью используются различные инструменты и понятия.

#### DispatchQueue (Очередь выполнения):

Это основной механизм для выполнения асинхронного кода в iOS и macOS.
Основная очередь (main queue) используется для обновления пользовательского интерфейса.
Фоновые очереди (background queues) используются для выполнения задач, которые не связаны с UI.

#### Thread (Поток):

Представляет собой отдельный поток выполнения в приложении.
В iOS рекомендуется избегать прямого управления потоками и использовать более высокоуровневые абстракции, такие как DispatchQueue.

#### Operation и OperationQueue:

Это более высокоуровневая абстракция по сравнению с DispatchQueue.
Позволяет создавать сложные операции с зависимостями.

#### GCD (Grand Central Dispatch):

Это низкоуровневая библиотека C, которая предоставляет доступ к функциональности многопоточности.

#### Deadlock (Взаимная блокировка):

Происходит, когда два или более потока ожидают завершения друг друга, что приводит к блокировке.
Например, если вы пытаетесь выполнить код на главной очереди из главной очереди с использованием sync, это вызовет deadlock.

#### Race Condition (Условие гонки):

Происходит, когда два потока пытаются получить доступ к одному и тому же ресурсу одновременно, и результат зависит от того, какой поток получит доступ первым.

#### Semaphore (Семафор):

Используется для управления доступом к ресурсу. Семафоры могут быть использованы для предотвращения условий гонки.

#### Что выносят в многопоточность:

1. Сетевые запросы
2. Обработка данных
3. Операции с базой данных
4. Работа с файловой системой
5. Тяжелые графические операции
6. Подготовка контента для отображения
7. Таймера и длительные операции

### Escaping

Когда вы передаете замыкание как аргумент функции в Swift, этот аргумент по умолчанию является "non-escaping", что означает, что замыкание будет выполняться в теле функции и не будет использоваться после завершения функции.

Однако иногда вам нужно сохранить замыкание и выполнить его позже, после завершения функции (например, асинхронные вызовы). В этом случае вы должны явно указать, что замыкание `escaping` с помощью ключевого слова `@escaping`.

```swift
func asyncFunction(completion: @escaping () -> Void) {
    DispatchQueue.global().async {
        // Делаем что-то в фоновом потоке
        DispatchQueue.main.async {
            completion() // Вызываем замыкание на главном потоке
        }
    }
}
```

В этом примере замыкание `completion` помечено как `@escaping`, потому что оно вызывается после завершения функции `asyncFunction`.